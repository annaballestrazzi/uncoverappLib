pageLength = 15,
lengthMenu = c(5, 15, 30, 50)
)))
}
# Also create a table to compare exact vs extended regions
comparison_table <- statistics_results %>%
select(SYMBOL, sample, region_type, Mean_Coverage, Percentage_Under_20x) %>%
pivot_wider(
names_from = region_type,
values_from = c(Mean_Coverage, Percentage_Under_20x),
names_sep = "_"
)
print(datatable(comparison_table,
caption = "Comparison of Exact vs Extended Region Coverage",
extensions = 'Buttons',
options = list(
dom = 'Bfrtip',
buttons = c('copy', 'csv', 'excel'),
pageLength = 15
)))
# Print summary of results
cat("Enhanced analysis complete!\n")
cat("Processed", length(gene_list), "genes and", length(list_bam), "BAM files\n")
cat("Key improvements:\n")
cat("- Separated statistics for exact gene regions vs extended regions\n")
cat("- Added more comprehensive coverage metrics\n")
cat("- Created comparison table to see the effect of region extension\n")
cat("\nResults saved to:\n")
cat("- gene_regions.bed: Genomic coordinates for each gene\n")
cat("- pileup_results.txt: Raw pileup data\n")
cat("- coverage_statistics.txt: Coverage statistics for exact regions\n")
cat("- detailed_coverage_statistics.txt: Statistics for both exact and extended regions\n")
View(my_gene_name)
gene.list <- "/home/anna/uncoverappLib/inst/Test/new 1.txt"
bam_example <- "/home/anna/uncoverappLib/inst/Test/bam1.list"
# Load required packages
library(GenomicDataCommons)
library(TxDb.Hsapiens.UCSC.hg19.knownGene)
library(TxDb.Hsapiens.UCSC.hg38.knownGene)
library(org.Hs.eg.db)
library(Rsamtools)
library(tidyverse)
library(GenomicRanges)
library(DT)
library(BiocParallel)
# Read gene list file
gene_list <- scan(gene.list, character(), quote = "")
# Read BAM list file
list_bam <- scan(bam_example, character(), quote = "")
# Set genome version - change this if needed
genome <- "hg19"
# Select the appropriate genome database
if (genome == "hg19") {
all_gene <- TxDb.Hsapiens.UCSC.hg19.knownGene
} else {
all_gene <- TxDb.Hsapiens.UCSC.hg38.knownGene
}
# Convert gene names to ENTREZ IDs using tidyverse approach
my_gene_name <- OrganismDbi::select(org.Hs.eg.db, key = gene_list, columns = "ENTREZID", keytype = "ALIAS") %>%
as_tibble()
ID <- my_gene_name$ENTREZID
# Check for unrecognizable gene names
unrecognized_genes <- ID[!ID %in% keys(all_gene, "GENEID")]
errore <- my_gene_name %>% filter(ENTREZID %in% unrecognized_genes)
if (nrow(errore) > 0) {
errore <- errore %>% rename("Unrecognizable gene names" = ALIAS)
print(errore)
stop("Please correct gene names and try again")
}
# Extract coordinates using tidyverse - STORING BOTH EXACT AND EXTENDED COORDINATES
extract_coordinates <- function(entrez_id) {
txid <- OrganismDbi::select(all_gene, entrez_id, "TXNAME", "GENEID")[["TXNAME"]]
gene.list <- "/home/anna/uncoverappLib/inst/Test/new 1.txt"
bam_example <- "/home/anna/uncoverappLib/inst/Test/bam1.list"
# Load required packages
library(GenomicDataCommons)
library(TxDb.Hsapiens.UCSC.hg19.knownGene)
library(TxDb.Hsapiens.UCSC.hg38.knownGene)
library(org.Hs.eg.db)
library(Rsamtools)
library(tidyverse)
library(GenomicRanges)
library(DT)
library(BiocParallel)
# Read gene list file
gene_list <- scan(gene.list, character(), quote = "")
# Read BAM list file
list_bam <- scan(bam_example, character(), quote = "")
# Set genome version - change this if needed
genome <- "hg19"
# Select the appropriate genome database
if (genome == "hg19") {
all_gene <- TxDb.Hsapiens.UCSC.hg19.knownGene
} else {
all_gene <- TxDb.Hsapiens.UCSC.hg38.knownGene
}
# Convert gene names to ENTREZ IDs using tidyverse approach
my_gene_name <- OrganismDbi::select(org.Hs.eg.db, key = gene_list, columns = "ENTREZID", keytype = "ALIAS") %>%
as_tibble()
ID <- my_gene_name$ENTREZID
# Check for unrecognizable gene names
unrecognized_genes <- ID[!ID %in% keys(all_gene, "GENEID")]
errore <- my_gene_name %>% filter(ENTREZID %in% unrecognized_genes)
if (nrow(errore) > 0) {
errore <- errore %>% rename("Unrecognizable gene names" = ALIAS)
print(errore)
stop("Please correct gene names and try again")
}
# Extract coordinates using tidyverse - STORING BOTH EXACT AND EXTENDED COORDINATES
extract_coordinates <- function(entrez_id) {
txid <- OrganismDbi::select(all_gene, entrez_id, "TXNAME", "GENEID")[["TXNAME"]]
cds <- OrganismDbi::exonsBy(all_gene, by = "tx", use.names = TRUE)
coor
gene.list <- "/home/anna/uncoverappLib/inst/Test/new 1.txt"
bam_example <- "/home/anna/uncoverappLib/inst/Test/bam1.list"
# Load required packages
library(GenomicDataCommons)
library(TxDb.Hsapiens.UCSC.hg19.knownGene)
library(TxDb.Hsapiens.UCSC.hg38.knownGene)
library(org.Hs.eg.db)
library(Rsamtools)
library(tidyverse)
library(GenomicRanges)
library(DT)
library(BiocParallel)
# Read gene list file
gene_list <- scan(gene.list, character(), quote = "")
# Read BAM list file
list_bam <- scan(bam_example, character(), quote = "")
# Set genome version - change this if needed
genome <- "hg19"
# Select the appropriate genome database
if (genome == "hg19") {
all_gene <- TxDb.Hsapiens.UCSC.hg19.knownGene
} else {
all_gene <- TxDb.Hsapiens.UCSC.hg38.knownGene
}
# Convert gene names to ENTREZ IDs using tidyverse approach
my_gene_name <- OrganismDbi::select(org.Hs.eg.db, key = gene_list, columns = "ENTREZID", keytype = "ALIAS") %>%
as_tibble()
ID <- my_gene_name$ENTREZID
# Check for unrecognizable gene names
unrecognized_genes <- ID[!ID %in% keys(all_gene, "GENEID")]
errore <- my_gene_name %>% filter(ENTREZID %in% unrecognized_genes)
if (nrow(errore) > 0) {
errore <- errore %>% rename("Unrecognizable gene names" = ALIAS)
print(errore)
stop("Please correct gene names and try again")
}
# Extract coordinates using tidyverse - STORING BOTH EXACT AND EXTENDED COORDINATES
extract_coordinates <- function(entrez_id) {
txid <- OrganismDbi::select(all_gene, entrez_id, "TXNAME", "GENEID")[["TXNAME"]]
cds <- OrganismDbi::exonsBy(all_gene, by = "tx", use.names = TRUE)
coor <- as.data.frame(cds[names(cds) %in% txid])
coordinate <- coor %>%
mutate(ENTREZID = entrez_id) %>%
inner_join(my_gene_name, by = "ENTREZID") %>%
# Store both exact and extended coordinates
mutate(
exact_start = start,
exact_end = end,
start = start - 10,  # extended start
end = end + 10       # extended end
)
return(coordinate)
}
# Use map from purrr to process all genes and bind rows together
pre <- map_dfr(ID, extract_coordinates)
gene.list <- "/home/anna/uncoverappLib/inst/Test/new 1.txt"
bam_example <- "/home/anna/uncoverappLib/inst/Test/bam1.list"
# Load required packages
library(GenomicDataCommons)
library(TxDb.Hsapiens.UCSC.hg19.knownGene)
library(TxDb.Hsapiens.UCSC.hg38.knownGene)
library(org.Hs.eg.db)
library(Rsamtools)
library(tidyverse)
library(GenomicRanges)
library(DT)
library(BiocParallel)
# Read gene list file
gene_list <- scan(gene.list, character(), quote = "")
# Read BAM list file
list_bam <- scan(bam_example, character(), quote = "")
# Set genome version - change this if needed
genome <- "hg19"
# Select the appropriate genome database
if (genome == "hg19") {
all_gene <- TxDb.Hsapiens.UCSC.hg19.knownGene
} else {
all_gene <- TxDb.Hsapiens.UCSC.hg38.knownGene
}
# Convert gene names to ENTREZ IDs using tidyverse approach
my_gene_name <- OrganismDbi::select(org.Hs.eg.db, key = gene_list, columns = "ENTREZID", keytype = "ALIAS") %>%
as_tibble()
ID <- my_gene_name$ENTREZID
# Check for unrecognizable gene names
unrecognized_genes <- ID[!ID %in% keys(all_gene, "GENEID")]
errore <- my_gene_name %>% filter(ENTREZID %in% unrecognized_genes)
if (nrow(errore) > 0) {
errore <- errore %>% rename("Unrecognizable gene names" = ALIAS)
print(errore)
stop("Please correct gene names and try again")
}
# Extract coordinates using tidyverse - STORING BOTH EXACT AND EXTENDED COORDINATES
extract_coordinates <- function(entrez_id) {
txid <- OrganismDbi::select(all_gene, entrez_id, "TXNAME", "GENEID")[["TXNAME"]]
cds <- OrganismDbi::exonsBy(all_gene, by = "tx", use.names = TRUE)
coor <- as.data.frame(cds[names(cds) %in% txid])
coordinate <- coor %>%
mutate(ENTREZID = entrez_id) %>%
inner_join(my_gene_name, by = "ENTREZID") %>%
# Store both exact and extended coordinates
mutate(
exact_start = start,
exact_end = end,
start = start - 10,  # extended start
end = end + 10       # extended end
)
return(coordinate)
}
# Use map from purrr to process all genes and bind rows together
pre <- map_dfr(ID, extract_coordinates)
# Format BED file using tidyverse - USE EXTENDED COORDINATES FOR BAM ANALYSIS
for_bed <- pre %>%
transmute(
chr = as.character(seqnames),
start = start,         # extended for complete coverage
end = end,             # extended for complete coverage
exact_start = exact_start,
exact_end = exact_end,
SYMBOL = ALIAS
) %>%
distinct()
# Set chromosome notation format
notation <- "chr"  # Change to "number" if needed
if (notation == "number") {
for_bed <- for_bed %>%
mutate(chr = str_replace(chr, "^.{0,3}", ""))
}
# Read BAM files and perform pileup
# Convert to GRanges using extended coordinates to capture all reads
for_grange <- GenomicRanges::makeGRangesFromDataFrame(
for_bed %>% select(chr, start, end, SYMBOL, exact_start, exact_end),
keep.extra.columns = TRUE,
seqnames.field = "chr"
)
param <- Rsamtools::ScanBamParam(which = for_grange)
# Set pileup parameters
mapq <- 20  # min mapping quality
base_qual <- 20  # min base quality
p_param <- Rsamtools::PileupParam(
distinguish_nucleotides = TRUE,
distinguish_strands = FALSE,
min_mapq = as.numeric(mapq),
min_base_quality = as.numeric(base_qual),
min_nucleotide_depth = 1,
max_depth = 150000
)
# Process BAM files using BiocParallel
process_bam_file <- function(bam_file) {
pileup_df <- Rsamtools::pileup(bam_file, scanBamParam = param, pileupParam = p_param)
return(pileup_df)
}
# Set up parallel processing
bp_param <- BiocParallel::MulticoreParam(workers = min(length(list_bam), 4))
df <- BiocParallel::bplapply(list_bam, process_bam_file, BPPARAM = bp_param)
# Process pileup results using tidyverse
# First check for which_label column - if absent, create dummy
lst1 <- map(df, function(x) {
if("which_label" %in% colnames(x)) {
return(dplyr::select(x, -which_label))
} else {
return(x)
}
})
lst2 <- map(lst1, ~distinct(.x))
riarrange.df <- function(pileup_data) {
pileup_data %>%
mutate(end = pos) %>%
group_by(seqnames, pos, end, nucleotide) %>%
summarise(count = sum(count), .groups = "drop") %>%
arrange(nucleotide) %>%
group_by(seqnames, pos, end) %>%
summarise(
value = as.numeric(sum(count)),
counts = paste(nucleotide, count, sep = ':', collapse = ';'),
.groups = "drop"
)
}
lst3 <- map(lst2, riarrange.df)
# Merge all pileup results
pp <- lst3 %>%
reduce(full_join, by = c("seqnames", "pos", "end")) %>%
replace_na(list(value = 0, counts = "")) %>%
as_tibble()
# Handle chromosome notation
if (notation == "number") {
pp <- pp %>%
mutate(seqnames = paste0("chr", seqnames)) %>%
relocate(seqnames)
}
# Get sample names
name_sample <- basename(list_bam)
# Create statistics dataframe
ppinp <- pp %>% rename(start = pos)
n <- length(colnames(ppinp)[-1:-3])
m <- rep(name_sample, each = 2)
colnames(ppinp)[-1:-3] <- paste0(c("sample_", "nucleotide_"), m[1:n])
# Create GRanges objects for overlaps
for_range_pp <- GenomicRanges::makeGRangesFromDataFrame(ppinp, keep.extra.columns = TRUE)
tp <- GenomicRanges::findOverlaps(query = for_range_pp, subject = for_grange, type = "any", select = "all")
# Create statistics using tidyverse - extract relevant info from overlaps
query_hits_df <- as.data.frame(for_range_pp[queryHits(tp)])
subject_hits_df <- as.data.frame(for_grange[subjectHits(tp)])
# Determine if each position is within exact or extended region
result_df <- tibble(
chromosome = query_hits_df$seqnames,
position = query_hits_df$start,
end = query_hits_df$end,
SYMBOL = subject_hits_df$SYMBOL,
exact_start = subject_hits_df$exact_start,
exact_end = subject_hits_df$exact_end
) %>%
mutate(region_type = case_when(
position >= exact_start & position <= exact_end ~ "exact",
TRUE ~ "extended"
))
# Map the sample columns
value_cols <- colnames(query_hits_df)[grepl("^sample_", colnames(query_hits_df))]
for (col in value_cols) {
result_df[[col]] <- query_hits_df[[col]]
}
# Get unique positions to avoid double-counting in statistics
stats_df <- result_df %>%
distinct(position, SYMBOL, region_type, .keep_all = TRUE)
# Extract sample columns for analysis
sample_cols <- colnames(stats_df)[grepl("^sample_", colnames(stats_df))]
# Create functions to process each sample and region type separately
create_sample_specific_df <- function(sample_col) {
stats_df %>%
select(chromosome, position, end, SYMBOL, region_type, all_of(sample_col)) %>%
rename(value = all_of(sample_col)) %>%
mutate(sample = sample_col)
}
# Create per-sample dataframes
sample_dfs <- map(sample_cols, create_sample_specific_df)
# Statistical analysis function - calculate stats for each region type separately
calculate_statistics <- function(df) {
df %>%
group_by(SYMBOL, sample, region_type) %>%
summarize(
Total_Positions = n(),
Total_Coverage = sum(value, na.rm = TRUE),
Mean_Coverage = mean(value, na.rm = TRUE),
Median_Coverage = median(value, na.rm = TRUE),
Min_Coverage = min(value, na.rm = TRUE),
Max_Coverage = max(value, na.rm = TRUE),
Positions_Under_20x = sum(value < 20, na.rm = TRUE),
Percentage_Under_20x = (sum(value < 20, na.rm = TRUE) / n()) * 100,
Positions_With_Zero_Coverage = sum(value == 0, na.rm = TRUE),
Percentage_Zero_Coverage = (sum(value == 0, na.rm = TRUE) / n()) * 100,
.groups = "drop"
) %>%
mutate(across(where(is.numeric), ~round(., 3)))
}
# Process all samples
statistics_results <- bind_rows(map(sample_dfs, calculate_statistics))
# Save the detailed statistics
write_tsv(statistics_results, "detailed_coverage_statistics.txt")
# For backward compatibility, create a version with just the exact region stats
exact_region_stats <- statistics_results %>%
filter(region_type == "exact") %>%
select(-region_type)
write_tsv(exact_region_stats, "coverage_statistics.txt")
# Save output to files
write_tsv(for_bed, "gene_regions.bed")
write_tsv(pp, "pileup_results.txt")
# Create an interactive table for the exact region statistics
if ("Percentage_Under_20x" %in% colnames(exact_region_stats)) {
dt_output <- datatable(exact_region_stats,
extensions = 'Buttons',
options = list(
dom = 'Bfrtip',
buttons = c('copy', 'csv', 'excel'),
pageLength = 15,
lengthMenu = c(5, 15, 30, 50)
))
dt_output <- formatStyle(dt_output,
'Percentage_Under_20x',
backgroundColor = styleInterval(c(5, 20), c('green', 'yellow', 'red'))
)
print(dt_output)
} else {
print(datatable(exact_region_stats,
extensions = 'Buttons',
options = list(
dom = 'Bfrtip',
buttons = c('copy', 'csv', 'excel'),
pageLength = 15,
lengthMenu = c(5, 15, 30, 50)
)))
}
# Also create a table to compare exact vs extended regions
comparison_table <- statistics_results %>%
select(SYMBOL, sample, region_type, Mean_Coverage, Percentage_Under_20x) %>%
pivot_wider(
names_from = region_type,
values_from = c(Mean_Coverage, Percentage_Under_20x),
names_sep = "_"
)
print(datatable(comparison_table,
caption = "Comparison of Exact vs Extended Region Coverage",
extensions = 'Buttons',
options = list(
dom = 'Bfrtip',
buttons = c('copy', 'csv', 'excel'),
pageLength = 15
)))
# Print summary of results
cat("Enhanced analysis complete!\n")
cat("Processed", length(gene_list), "genes and", length(list_bam), "BAM files\n")
cat("Key improvements:\n")
cat("- Separated statistics for exact gene regions vs extended regions\n")
cat("- Added more comprehensive coverage metrics\n")
cat("- Created comparison table to see the effect of region extension\n")
cat("\nResults saved to:\n")
cat("- gene_regions.bed: Genomic coordinates for each gene\n")
cat("- pileup_results.txt: Raw pileup data\n")
cat("- coverage_statistics.txt: Coverage statistics for exact regions\n")
cat("- detailed_coverage_statistics.txt: Statistics for both exact and extended regions\n")
options(timeout = 600)  # increase to 10 minutes
BiocManager::install("BSgenome.Hsapiens.UCSC.hg19")
source("~/uncoverappLib/traials/trial_3/EnsDb_package,R")
source("~/uncoverappLib/traials/trial_3/EnsDb_package,R")
source("~/uncoverappLib/traials/trial_3/EnsDb_package.R")
source("~/uncoverappLib/traials/trial_3/EnsDb_package.R")
source("~/uncoverappLib/traials/trial_3/EnsDb_package.R")
#!/usr/bin/env Rscript
library(tidyverse)
library(EnsDb.Hsapiens.v86)
library(ensembldb)
gene_file <- "gene.txt"
gene_list <- scan(gene_file, character(), quote = "")
source("~/uncoverappLib/inst/shiny-dir/preprocessing_7.R")
source("~/uncoverappLib/inst/shiny-dir/preprocessing_7.R")
source("~/uncoverappLib/inst/shiny-dir/preprocessing_7.R")
shiny::runApp("/home/anna/uncoverappLib/inst/shiny-app")
library(uncoverappLib)
run_app()
library(uncoverappLib)
run_app()
shiny::runApp("/home/anna/uncoverappLib/inst/shiny-app")
suppressPackageStartupMessages({
library(dplyr)
library(tibble)
library(rlist)
library(Rsamtools)
library(GenomicRanges)
library(IRanges)
library(OrganismDbi)
library(org.Hs.eg.db)
library(TxDb.Hsapiens.UCSC.hg19.knownGene)
library(TxDb.Hsapiens.UCSC.hg38.knownGene)
library(AnnotationDbi)
library(S4Vectors)
})
# Test overlap
test_data <- data.frame(
chromosome = "chr1",
start = 69091,
end = 69091,
coverage = 50
)
test_annotation <- data.frame(
Chromosome = "chr1",
start = 69091,
end = 69091,
GENENAME = "OR4F5"
)
gr1 <- makeGRangesFromDataFrame(test_data)
gr2 <- makeGRangesFromDataFrame(test_annotation)
overlaps <- findOverlaps(gr1, gr2)
# Dovrebbe trovare 1 overlap
print(length(overlaps))  # = 1 âœ…
hlbj
setwd("~/Desktop/uncoverappLib")
annotate_all_lowcov(
sample_data = "~/Desktop/risultati_check/output/Tue_Nov_18_2025.bed",
target_sample = "17038.regions_4col",
coverage_threshold = 60,
genome = "hg38",
annotation_file = NULL,
output_intersect = "~/Desktop/risultati_check/output2/annotated_all_lowcov.tsv",
output_formatted = "~/Desktop/risultati_check/output2/annotated_all_lowcov.xlsx"
)
library(uncoverappLib)
devtools::load_all()
annotate_all_lowcov(
sample_data = "~/Desktop/risultati_check/output/Tue_Nov_18_2025.bed",
target_sample = "17038.regions_4col",
coverage_threshold = 60,
genome = "hg38",
annotation_file = NULL,
output_intersect = "~/Desktop/risultati_check/output2/annotated_all_lowcov.tsv",
output_formatted = "~/Desktop/risultati_check/output2/annotated_all_lowcov.xlsx"
)
setup_uncoverapp()
?setup_uncoverapp
?getAnnotationFiles
setwd("~/Desktop/uncoverappLib")
devtools::load_all()
